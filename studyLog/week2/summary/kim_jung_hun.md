# 2주차

## 문장

- let은 현재 스코프에 새로운 변수를 선언한다.
- 모든 블록 ({ })은 그만의 스코프를 생성한다.
- const는 let과 달리 초기화를 반드시 해줘야하며, 변수가 나중에 선언될 수 없다.
    - const에는 다른 값을 할당할 수 없지만 객체나 배열의 값을 바꾸는 것은 가능
- 자바스크립트에서는 할당문, 호출문, delete 외에도 모든 종류의 표현식을 문장 위치에 쓸 수 있음
- **객체를 써서 switch 문 대신하기 - 각 케이스별로 처리해야 할 동작을 구현한 함수들로 객체를 채우고, case 변수와 일치하는 값을 객체의 키로 사용한다.**
- for 문보다 forEach와 같은 배열 메서드를 사용하는 것이 좋다.

## 함수

- function 연산자는 함수 객체를 만든다.
- prototype 속성에 call, bind와 같은 메서드를 상속
- 함수가 호출되면 활성 객체가 만들어지고 힙에 저장한다.
    - 함수 객체 참조
    - 함수를 호출한 측의 활성 객체에 대한 참조
    - 함수 호출이 끝나고 실행을 재개하기 위한 정보
    - 함수 매개변수, 함수 변수
    - this 참조
- 함수 객체는 함수 실행 코드에 대한 참조, 활성 객체에 대한 참조 (클로저 원리)를 포함
- **함수 객체가 외부 함수에 대한 활성 객체의 참조를 가지는 방식**을 클로저라고 한다.
- 가비지 콜렉터의 특성을 이용한 방식

## 제너레이터

- ES6에 추가된 문법이기는 하지만 yeild, value,next 등 낯설고 예측하기 힘든 속성들이 포함
- 하지만 유용하게 사용할 수 있음
    - 함수를 반환하는 함수, 호출될 때마다 등록한 동작
- 제너레이터는 순수함수와 비순수 함수 사이의 경계에 있다.
- 제너레이터는 상태를 가지고 있을 수도 있지만, 상태 정보는 팩토리 클로저에 숨겨져 있다.
- 상태는 제너레이터를 호출하는 경우에만 변경된다.
- 무엇이 순수하고 무엇이 순수하지 않아야 하는지 제너레이터로 판단할 수 있다.
- **Closure + 제너레이터 = 상태관리 (?)**

## 예외

- 예상되는 모든 출력 값을 반환 값으로 다루고, 그렇지 않은 것만 예외로 남겨둔다.

## 프로그램

- 전역변수는 악의 근원
- 모듈은 일반적으로 하나의 함수, 함수로 가득한 한 개의 객체와 같이 한 가지만 익스포트 해야한다.
- 좋은 프로그래밍은 좋은 모듈 설계에 달렸다.
    - 좋은 모듈은 응집도가 높다.
    - 모듈의 모든 요소가 어우러져 하나의 목적을 이루기 위해 함께 동작한다.
    - 서로에게 의존성이 낮은 모듈이 좋은 모듈이다.
